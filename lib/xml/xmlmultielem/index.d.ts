interface XmMultiElem<T> extends XmElem<T> {
  [index: number]: XmlElem<T>;

  /**
   * Возвращает количество дочерних элементов.
   */
  ChildNum: number;

  /**
   * Возвращает документ, к которому относится данный объект.
   */
  Doc: XmlDocument;

  /**
   * Возвращает массив, указанный в атрибуте `FOREIGN-ARRAY` текущего элемента.
   */
  ForeignArray: T[];

  /**
   * Возвращает `true` если существует хоть один соответствующий множественный элемент.
   */
  HasValue: boolean;

  /**
   * Возвращает массив всех соответствующих множественных элементов.
   * Сам по себе данный метод не несет особого смысла, поскольку объект
   * {@link XmlMultiElem} сам является массивом, но, в сочетании с одноименным
   * методом объекта {@link XmlElem} позволяет создавать универсальный код для
   * работы как с обычными так и множественными элементами.
   * @example
   * ```
   * // Возвращает массив из всех элементов profession_id
   * const array = candidate.profession_id.Instances;
   * Возвращает массив из единственного элемента location_id
   * const array = candidate.location_id.Instances;
   * ```
   */
  Instances: T[];

  /**
   * Всегда возвращает `false`.
   * Аналогичный метод объекта {@link XmlElem} всегда возвращает `false`.
   * Это позволяет по конструкции вида `candidate.profession_id.IsMultiElem` определять
   * был ли элемент `profession_id` описан c атрибутом `MULTIPLE=1`.
   */
  IsMultiElem: boolean;

  /**
   * Возвращает имя соответствующего множественного элемента.
   */
  Name: string;

  /**
   * Возвращает родительский элемент текущего элемента.
   */
  Parent: XmlTopElem | never;

  /**
   * Возвращает константу на языке {@link XQuery} в виде последовательности из значений соответствующих множественных элементов.
   */
  XQueryLiteral: string;

  /**
   * Добавляет дочерний элемент и возвращает указатель на него.
   * Если текущий элемент создан по форме, то он должен быть простым массивом.
   * При этом аргументы для вызова функции не требуются.
   * Если текущий элемент является динамическим (то есть построенным без формы),
   * то добавляется дочерний динамический элемент с именем и типом, указанных в качестве аргументов.
   * @param {string} name - Имя дочернего элемента.
   * @param {string} type - Тип дочернего элемента.
   * @returns {XmlElem<T>}
   */
  Add(name?: string, type?: string): XmlElem<T>;

  /**
   * Добавляет дочерний элемент и возвращает указатель на него.
   * Если текущий элемент создан по форме, то он должен быть простым массивом.
   * При этом аргументы для вызова функции не требуются.
   * Если текущий элемент является динамическим (то есть построенным без формы),
   * то добавляется дочерний динамический элемент с именем и типом, указанных
   * в качестве аргументов.
   * @param {string} name - Имя дочернего элемента.
   * @param {string} type - Тип дочернего элемента.
   * Смотрите также {@link InsertChild}.
   */
  AddChild(name?: string, type?: string): XmlElem<T>;

  /**
   * Копирует в текущий элемент данные из другого элемента, включая дочерние элементы.
   * Значения всех совпадающим по имени элементов копируются,
   * элементы с атрибутом `MULTIPLE` при этом синхронизируются по количеству.
   * Если присваиваемый и текущий элементы были созданы по разным формам -
   * присваивются значения только по совпадающим полям.
   * @param {XmlElem<K>} element - Присваиваемый элемент.
   */
  AssignElem<K>(element: XmlElem<K>): void;

  /**
   * Проверяет существует ли соответствующий множественный элемент с заданным значением.
   * @param {K} value - Заданное значение.
   */
  ByValueExists<K>(value: K): boolean;

  /**
   * Возвращает дочерний элемент по имени.
   * Если элемента с заданным именем нет, выдает ошибку.
   * Смотри также методы {@link OptChild} и {@link EvalPath}.
   * @param {string} name - Имя дочернего элемента.
   */
  Child(name: string): XmlElem<T> | never;

  /**
   * Возвращает дочерний элемент по индексу.
   * Если элемента с заданным индексом нет, выдает ошибку.
   * Смотри также методы {@link OptChild} и {@link EvalPath}.
   * @param {index} index - Индекс дочернего элемента.
   */
  Child(index: number): XmlElem<T> | never;


  /**
   * Удаляет все соответствующие множественные элементы.
   */
  Clear(): void;

  /**
   * @deprecated
   * Удаляет все соответствующие множественные элементы.
   */
  DeleteAll(): void;

  /**
   * Удаляет соответствующий множественный элемент с заданным значением.
   * Если таких элементов несколько, удаляет первый.
   * @throws {@link Error} В случае отсутствия таких элементов возвращает ошибку.
   */
  DeleteByValue(): void | never;

  /**
   * Удаляет первый найденный дочерний элемент с заданным значением ключевого поля.
   * Если дочерний элемент не найден, возвращается ошибка.
   * @param {K} keyValue - Значение ключа.
   * @param {string} keyName - Имя элемента, являющегося ключом. Если имя ключа не указано, используется первичный ключ.
   */
  DeleteChildByKey<K>(value: K, name?: string): void;

  /**
   * Удаляет все дочерние элементы, удовлетворяющие заданому условию.
   * @param {string} expression - Строка, содержащая выражение/условие, вычисляемое относительно каждого значения элемента.
   * Если выражение не указано, удаляются все дочерние элементы.
   */
  DeleteChildren(expression: string): void;

  /**
   * Находит соответствующий множественный элемент с заданным значением ключевого поля.
   * Если такой элемент не найден, возвращает ошибку.
   * @param {string} value - Значение ключа.
   * @param {string} name - Имя элемента, являющегося ключом. Если имя ключа не указано, используется первичный ключ.
   * @returns {XmlElem<T>} - Объект {@link XmlElem}.
   */
  GetByKey<K>(value: K, name?: string): XmlElem<T>;

  /**
   * Ищет соответствующий множественный элемент с заданным ключевым элементом.
   * Если не находит, то добавляет новый дочерний элемент, и его ключевому полю присваивает заданное значение.
   * Возвращает ранее существовавший или вновь созданный дочерний элемент.
   * @param {K} value - Значение ключа.
   * @param {string} name - Имя элемента, являющегося ключом. Если имя ключа не указано, используется первичный ключ.
   * @returns {XmlElem<T>} Объект {@link XmlElem}.
   */
  ObtainByKey<K>(value: K, name?: string): XmlElem<T>;

  /**
   * Возвращает дочерний элемент с заданным значением ключевого поля.
   * Если дочерний элемент не найден, возвращает ошибку.
   * Смотри также {@link GetOptChildByKey}.
   * @param {K} keyValue - Значение ключа.
   * @param {string} keyName - Имя элемента, являющегося ключом (String). Необязательный аргумент.
   * Если имя ключа не указано, используется первичный ключ.
   */
  GetChildByKey<K>(value: K, name?: string): XmlElem<unknown>;

  /**
   * Возвращает дочерний элемент с заданным значением ключевого поля.
   * Если дочерний элемент не найден, возвращает undefined.
   * @param {K} value - Значение ключа.
   * @param {string} name - Имя элемента, являющегося ключом. Если имя ключа не указано, используется первичный ключ.
   */
  GetOptChildByKey<K>(value: K, name?: string): XmlElem<T> | undefined;

  /**
   * Находит элемент, относящийся к данному объекту по ключу.
   * В случае его отсутствия, добавляет элемент в соответствующую позицию по возрастанию ключа.
   * @param {K} value - Значение ключа.
   * @param {string} name - Имя элемента, являющегося ключом. Если имя ключа не указано, используется первичный ключ.
   * @returns {XmlElem<T>} Объект {@link XmlElem}.
   */
  ObtainByKeySorted<K>(value: K, name: string): XmlElem<T>;

  /**
   * Ищет соответствующий множественный элемент с заданным значением.
   * Если не находит, добавляет новый элемент и присваивает ему заданное значение.
   * @param {K} value - Значение элемента.
   */
  ObtainByValue<K>(value: K): XmlElem<T>;

  /**
   * Ищет дочерний элемент с заданным ключевым элементом. Если не находит,
   * то добавляет новый дочерний элемент, и его ключевому полю присваивает заданное значение.
   * Возвращает ранее существовавший или вновь созданный дочерний элемент.
   * @param {K} value - Значение ключа.
   * @param {string} name - Имя элемента, являющегося ключом. Если имя ключа не указано, используется первичный ключ.
   */
  ObtainChildByKey<K>(value: K, name?: string): XmlElem<T>;

  /**
   * Возвращает дочерний элемент. Находит дочерний элемент по имени.
   * Если элемента с заданным именем нет, выдает `undefined`.
   * Смотри также метод {@link Child}.
   * @param {string} name - Имя дочернего элемента.
   */
  OptChild(name: string): XmlElem<T>;
}

type XmlMultiElem<T> = XmMultiElem<T> & T;
